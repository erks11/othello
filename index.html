<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>おせろ</title>
</head>

<body>
  <style>
    #tables {
      display: flex;
    }

    #othello {
      border-collapse: collapse;
      background-color: #008080;
      border: 10px solid black;
      border-top-style: none;
      border-left-style: none;
    }

    #battle-status {
      background-color: lavender;
      width: 200px;
      height: 240px;
    }

    th {
      background-color: black;
      color: blanchedalmond;
      font-size: xx-small;
    }

    #othello td {
      border: solid 1px black;
      width: 24px;
      height: 24px;
    }

    #othello td.active {
      background: lightseagreen;
    }

    #othello div {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      margin: 1px auto;
    }

    div.stone {
      transition: transform 1s linear 0s, background-color 0s linear 0.5s;
    }

    div.black-stone {
      transform: rotateY(180deg);
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: solid 1px #000000;
      background-color: #000000;
      margin: 1px auto;
    }

    div.white-stone {
      transform: rotateY(360deg);
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: solid 1px #000000;
      background-color: #fff8dc;
      margin: 1px auto;
    }

    div.label-you::before {
      content: "あなたの番です";
    }

    div.label-me::before {
      content: "わたしの番です";
    }
  </style>
  <div id="tables">
    <table id="othello">
      <tr>
        <th></th>
        <th>a</th>
        <th>b</th>
        <th>c</th>
        <th>d</th>
        <th>e</th>
        <th>f</th>
        <th>g</th>
        <th>h</th>
      </tr>
      <tr>
        <th>1</th>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
      </tr>
      <tr>
        <th>2</th>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
      </tr>
      <tr>
        <th>3</th>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
      </tr>
      <tr>
        <th>4</th>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
      </tr>
      <tr>
        <th>5</th>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
      </tr>
      <tr>
        <th>6</th>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
      </tr>
      <tr>
        <th>7</th>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
      </tr>
      <tr>
        <th>8</th>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
        <td>
          <div></div>
        </td>
      </tr>
    </table>

    <table id="battle-status">
      <tr>
        <td>○わたし</td>
      </tr>
      <tr>
        <td>
          <div></div>
        </td>
      </tr>
      <tr>
        <td id="stone"></td>
      </tr>
      <tr>
        <td id="winner"></td>
      </tr>
      <tr>
        <td>
          <button id="reset">reset</button>
          <!-- <button>GiveUp</button> -->
        </td>
      </tr>
      <tr>
        <td>●あなた</td>
      </tr>
    </table>
  </div>
  <script>
    function reflectHTML() {
      const td_list = document.querySelectorAll("#othello td");
      const list = document.querySelectorAll("#othello td div");
      const tdtag = document.querySelector("#battle-status td div");
      const stoneStatus = document.querySelector("#stone");
      const winnerStatus = document.querySelector("#winner");
      const resetButton = document.querySelector("#reset");
      let mycolor;

      const observerSetter = function (obj, prop, value) {
        if (prop === "boardStatus") {
          // 盤面に反映する
          for (let i = 0; i < value.length; i++) {
            for (let k = 0; k < value[i].length; k++) {
              td_list[8 * i + k].removeAttribute("class");
              if (value[i][k] > 0 && list[8 * i + k].classList.length > 0) {
                list[8 * i + k].setAttribute("class", "stone");
              }
              if (value[i][k] === -1) {
                td_list[8 * i + k].setAttribute("class", "active");
              } else if (value[i][k] === 1) {
                list[8 * i + k].classList.add("white-stone");
              } else if (value[i][k] === 2) {
                list[8 * i + k].classList.add("black-stone");
              } else {
                list[8 * i + k].removeAttribute("class");
              }
            }
          }
        }
        if (prop === "stoneCount") {
          console.log(value);
          stoneStatus.innerHTML = value;
        }

        if (prop === "winner") {
          if (value === -1) {
            winnerStatus.innerHTML = "引き分け";
          } else if (value === 1) {
            winnerStatus.innerHTML = "わたしの勝ち";
          } else if (value === 2) {
            winnerStatus.innerHTML = "あなたの勝ち";
          } else {
            winnerStatus.innerHTML = "";
          }
        }
        if (prop === "currentColor") {
          mycolor = value;
          if (value === 1) {
            tdtag.setAttribute("class", "label-me");
          } else {
            tdtag.setAttribute("class", "label-you");
          }
        }
        obj[prop] = value;

        return true;
      }

      const othello = new Othello(observerSetter);
      window.othello = othello;

      // buttonを押したらresetしたい
      resetButton.addEventListener("click", () => {
        if (mycolor === othello.initialColor) {
          othello.reset();
        }
      });

      // clickしたときにオセロを置きたい

      for (let i = 0; i < list.length; i++) {
        list[i].addEventListener(
          "click",
          (i2 => {
            return e => {
              let statusArr = othello.data.boardStatus;
              const mycolor = othello.data.currentColor;
              // statusArrをクリックした状態に反映したい
              let x = Math.floor(i2 / 8);
              let y = i2 % 8;

              if (statusArr[x][y] > 0) {
                return;
              }
              if (statusArr[x][y] != -1) {
                return;
              }
              statusArr[x][y] = mycolor;
              const result = othello.executeOneTurn(
                statusArr,
                { x: x, y: y },
                mycolor
              );

              window.setTimeout(() => {
                othello.executeCOMTurn(result.statusArr, result.activeArr);
              }, 2000);
            };
          })(i),
          false
        );
      }
    }

    class Othello {
      constructor(setter) {
        const data = {
          winner: 0,
          blackStone: 2,
          whiteStone: 2,
          boardStatus: [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 2, 0, 0, 0],
            [0, 0, 0, 2, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0]
          ],
          currentColor: 2
        };
        const observer = {
          set: setter
        }
        const observe = new Proxy(data, observer);
        this.data = observe;
        (this.initialBoardStatus = [
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 1, 2, 0, 0, 0],
          [0, 0, 0, 2, 1, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0]
        ]);
        // 黒が自分とする
        this.initialColor = 2;


        this.init(this.initialBoardStatus, this.initialColor);
      }

      init(initBoardStatus, initialColor) {
        const result = this.judgeBoard(initBoardStatus, initialColor);
        this.countStone(initBoardStatus);

      }

      // trigger() {
      //   if (typeof this.callback === "function") {
      //     this.callback();
      //   }
      // }

      reset() {
        const boardStatus = [
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0]
        ];
        this.init(this.initialBoardStatus);
      }

      // コンピュータの１ターンの処理
      executeCOMTurn(statusArr, activeArr) {
        this.data.currentColor = 1;
        const comColor = this.data.currentColor;
        // activeである-1の座標が入った配列を作る
        // その配列の中からランダムで、白が置く場所をきめる
        const cood =
          activeArr[Math.floor(Math.random() * (activeArr.length - 1))];

        // そこにおく
        statusArr[cood.x][cood.y] = comColor;
        // それを反映させる
        this.executeOneTurn(statusArr, cood, comColor);
      }

      // オセロ１ターンの処理
      executeOneTurn(statusArr, cood, currentColor) {
        currentColor = this.data.currentColor;
        // ひっくり返す
        let reverseStatusArr = this.reverseStone(statusArr, {
          x: cood.x,
          y: cood.y
        });

        if (currentColor === 1) {
          currentColor = 2;
          this.data.currentColor = 2;
        } else {
          currentColor = 1;
          this.data.currentColor = 1;
        }
        // 次における場所があるかを判断する
        let result = this.judgeBoard(reverseStatusArr, currentColor);
        this.countStone(result.statusArr);

        if (result.isContinue) {
          return result;
        }

        // pass判定
        let pass = 0;
        while (!result.isContinue) {
          if (currentColor === 1) {
            currentColor = 2;
            this.data.currentColor = 2;
          } else {
            currentColor = 1;
            this.data.currentColor = 1;
          }
          pass++;
          // passが２回だったらゲーム終了する
          if (pass >= 2) {
            this.finish(result.statusArr);
            break;
          }

          result = this.judgeBoard(result.statusArr, currentColor);
        }
      }

      finish(statusArr) {
        const res = this.countStone(statusArr);
        // 勝敗を決める
        if (res.white === res.black) {
          this.data.winner = -1;
        } else if (res.white > res.black) {
          this.data.winner = 1;
        } else {
          this.data.winner = 2;
        }
      }

      // 黒と白の石の数を数える
      countStone(statusArr) {
        let whiteCount = 0;
        let blackCount = 0;
        for (let i = 0; i < statusArr.length; i++) {
          for (let k = 0; k < statusArr[i].length; k++) {
            if (statusArr[i][k] === 1) {
              whiteCount++;
            } else if (statusArr[i][k] === 2) {
              blackCount++;
            }
          }
        }
        this.data.stoneCount = "●:" + blackCount + " ○:" + whiteCount;
        return { white: whiteCount, black: blackCount };
      }

      reverseStone(statusArr, cood) {
        let statusArrText = JSON.stringify(statusArr);
        let reverseStatusArr = JSON.parse(statusArrText);
        // 置かれた石の周り８方向をみたい
        let resArr = this.judgeGridActive(
          reverseStatusArr,
          reverseStatusArr[cood.x][cood.y],
          cood.x,
          cood.y
        );

        // searchOnewayでarrとxv,yvを受け取り、statusArrを変えてreturnしたい
        resArr.forEach(res => {
          // resArrのresultがtrueのものに対して、処理を行う
          // ここでx,yを定義し、多方向でひっくり返せるようにする
          let x = cood.x;
          let y = cood.y;
          if (res.result) {
            res.arr.forEach(i => {
              if (i != reverseStatusArr[x][y]) {
                x += res.xv;
                y += res.yv;
                reverseStatusArr[x][y] = reverseStatusArr[cood.x][cood.y];
              }
            });
          }
        });
        return reverseStatusArr;
      }

      judgeBoard(statusArr, mycolor) {
        let statusArrText = JSON.stringify(statusArr);
        let judgeStatusArr = JSON.parse(statusArrText);
        mycolor = this.data.currentColor;
        // 白が1　黒が2
        // 64マス全てに対して、置けるかどうか判断したい
        let isContinue = false;
        let activeArr = [];
        for (let i = 0; i < judgeStatusArr.length; i++) {
          for (let k = 0; k < judgeStatusArr[i].length; k++) {
            if (judgeStatusArr[i][k] > 0) {
              // すでに置いてあったらスルーする
              continue;
            }
            // いったんactiveを非表示にする
            if (judgeStatusArr[i][k] === -1) {
              judgeStatusArr[i][k] = 0;
            }

            // 置けるかどうか判断する
            // 置けるならactiveを表示
            let resArr = this.judgeGridActive(judgeStatusArr, mycolor, i, k);
            // resArrのresultに一つでもtrueがあればそのtdをactiveにする
            resArr.forEach(res => {
              if (res.result) {
                activeArr.push({ x: i, y: k });
                isContinue = true;
                judgeStatusArr[i][k] = -1;
              }
            });
          }
        }
        this.data.boardStatus = judgeStatusArr;
        return {
          isContinue: isContinue,
          statusArr: judgeStatusArr,
          activeArr: activeArr
        };
      }

      // 周囲8マスをみてる
      judgeGridActive(statusArr, mycolor, i, k) {
        mycolor = this.data.currentColor;
        let res;
        let resArr = [];
        for (let i2 = i - 1; i2 <= i + 1; i2++) {
          for (let k2 = k - 1; k2 <= k + 1; k2++) {
            // 自分自身なのでスルー
            if (i2 === i && k2 === k) {
              continue;
            }
            res = this.searchOneway(
              statusArr,
              { x: i, y: k },
              i2 - i,
              k2 - k,
              mycolor
            );
            resArr.push(res);
          }
        }
        return resArr;
      }

      searchOneway(statusArr, cood, xv, yv, mycolor) {
        mycolor = this.data.currentColor;
        let result = false;
        let arr = [];
        const x = cood.x;
        const y = cood.y;
        let new_cood = { x: x, y: y };
        while (
          new_cood.x < 8 &&
          new_cood.x >= 0 &&
          (new_cood.y < 8 && new_cood.y >= 0)
        ) {
          new_cood.x += xv;
          new_cood.y += yv;
          if (
            new_cood.x >= 0 &&
            new_cood.y >= 0 &&
            new_cood.x < 8 &&
            new_cood.y < 8
          ) {
            let stat = statusArr[new_cood.x][new_cood.y];
            arr.push(stat);
            // 隣が空白か、自分の色だったら抜ける
            if (stat <= 0 || stat == mycolor) {
              break;
            }
          }
        }
        // arr[0]が空白じゃなくて、自分の色でもない
        // arr[1]以上にずっと空白がないかつ自分の色がいる
        if (arr.length >= 2 && arr[arr.length - 1] === mycolor) {
          result = true;
        }
        return { arr: arr, xv: xv, yv: yv, result: result };
      }
    }

    window.onload = reflectHTML;
  </script>
</body>

</html>